<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Using PyTorch Hooks for the Dynamic U-Net Architecture | Dilip Thiagarajan</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Using PyTorch Hooks for the Dynamic U-Net Architecture" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture." />
<meta property="og:description" content="A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture." />
<link rel="canonical" href="https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html" />
<meta property="og:url" content="https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html" />
<meta property="og:site_name" content="Dilip Thiagarajan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-18T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture.","headline":"Using PyTorch Hooks for the Dynamic U-Net Architecture","@type":"BlogPosting","dateModified":"2020-03-18T00:00:00-05:00","datePublished":"2020-03-18T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html"},"url":"https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/technical_blog/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://dthiagarajan.github.io/technical_blog/feed.xml" title="Dilip Thiagarajan" /><link rel="shortcut icon" type="image/x-icon" href="/technical_blog/images/favicon.ico"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Using PyTorch Hooks for the Dynamic U-Net Architecture | Dilip Thiagarajan</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Using PyTorch Hooks for the Dynamic U-Net Architecture" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture." />
<meta property="og:description" content="A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture." />
<link rel="canonical" href="https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html" />
<meta property="og:url" content="https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html" />
<meta property="og:site_name" content="Dilip Thiagarajan" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-03-18T00:00:00-05:00" />
<script type="application/ld+json">
{"description":"A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture.","headline":"Using PyTorch Hooks for the Dynamic U-Net Architecture","@type":"BlogPosting","dateModified":"2020-03-18T00:00:00-05:00","datePublished":"2020-03-18T00:00:00-05:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html"},"url":"https://dthiagarajan.github.io/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

<link href="https://unpkg.com/@primer/css/dist/primer.css" rel="stylesheet" />
<link rel="stylesheet" href="//use.fontawesome.com/releases/v5.0.7/css/all.css"><link type="application/atom+xml" rel="alternate" href="https://dthiagarajan.github.io/technical_blog/feed.xml" title="Dilip Thiagarajan" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">
    <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"> </script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js" integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js" integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI" crossorigin="anonymous"></script>
    <script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement( document.body, {
        delimiters: [
            {left: "$$", right: "$$", display: true},
            {left: "[%", right: "%]", display: true},
            {left: "$", right: "$", display: false}
        ]}
        );
    });
    </script>


<script>
function wrap_img(fn) {
    if (document.attachEvent ? document.readyState === "complete" : document.readyState !== "loading") {
        var elements = document.querySelectorAll(".post img");
        Array.prototype.forEach.call(elements, function(el, i) {
            if (el.getAttribute("title")) {
                const caption = document.createElement('figcaption');
                var node = document.createTextNode(el.getAttribute("title"));
                caption.appendChild(node);
                const wrapper = document.createElement('figure');
                wrapper.className = 'image';
                el.parentNode.insertBefore(wrapper, el);
                el.parentNode.removeChild(el);
                wrapper.appendChild(el);
                wrapper.appendChild(caption);
            }
        });
    } else { document.addEventListener('DOMContentLoaded', fn); }
}
window.onload = wrap_img;
</script>

<script>
    document.addEventListener("DOMContentLoaded", function(){
    // add link icon to anchor tags
    var elem = document.querySelectorAll(".anchor-link")
    elem.forEach(e => (e.innerHTML = '<i class="fas fa-link fa-xs"></i>'));
    // remove paragraph tags in rendered toc (happens from notebooks)
    var toctags = document.querySelectorAll(".toc-entry")
    toctags.forEach(e => (e.firstElementChild.innerText = e.firstElementChild.innerText.replace('¶', '')))
    });
</script>
</head><body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/technical_blog/">Dilip Thiagarajan</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/technical_blog/about/">About Me</a><a class="page-link" href="/technical_blog/search/">Search</a><a class="page-link" href="/technical_blog/categories/">Tags</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Using PyTorch Hooks for the Dynamic U-Net Architecture</h1><p class="page-description">A look into how you can use PyTorch hooks, and using it to set up the dynamic U-Net architecture.</p><p class="post-meta post-meta-title"><time class="dt-published" datetime="2020-03-18T00:00:00-05:00" itemprop="datePublished">
        Mar 18, 2020
      </time>
       • <span class="read-time" title="Estimated read time">
    
    
      26 min read
    
</span></p>

    
      <p class="category-tags"><i class="fas fa-tags category-tags-icon"></i></i> 
      
        <a class="category-tags-link" href="/technical_blog/categories/#pytorch">pytorch</a>
        &nbsp;
      
        <a class="category-tags-link" href="/technical_blog/categories/#hooks">hooks</a>
        
      
      </p>
    

    
      
        <div class="pb-5 d-flex flex-wrap flex-justify-end">
          <div class="px-2">

    <a href="https://github.com/dthiagarajan/technical_blog/tree/master/_notebooks/2020-03-18-Dynamic-UNet-and-PyTorch-Hooks.ipynb" role="button">
<img class="notebook-badge-image" src="/technical_blog/assets/badges/github.svg" alt="View On GitHub">
    </a>
</div><div class="px-2">
    <a href="https://colab.research.google.com/github/dthiagarajan/technical_blog/blob/master/_notebooks/2020-03-18-Dynamic-UNet-and-PyTorch-Hooks.ipynb">
        <img class="notebook-badge-image" src="/technical_blog/assets/badges/colab.svg" alt="Open In Colab"/>
    </a>
</div>
        </div>
      </header>

  <div class="post-content e-content" itemprop="articleBody">
    <ul class="section-nav">
<li class="toc-entry toc-h2"><a href="#Overview">Overview </a></li>
<li class="toc-entry toc-h2"><a href="#Encoder-Setup">Encoder Setup </a></li>
<li class="toc-entry toc-h2"><a href="#Decoder-Setup">Decoder Setup </a>
<ul>
<li class="toc-entry toc-h3"><a href="#Getting-Shapes-Using-Hooks">Getting Shapes Using Hooks </a></li>
<li class="toc-entry toc-h3"><a href="#Constructing-the-Decoder">Constructing the Decoder </a></li>
<li class="toc-entry toc-h3"><a href="#Model-Forward-Using-Hooks">Model Forward Using Hooks </a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#Testing-on-the-CamVid-Dataset">Testing on the CamVid Dataset </a></li>
</ul><!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-03-18-Dynamic-UNet-and-PyTorch-Hooks.ipynb
-->

<div class="container" id="notebook-container">
        
    
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Overview">
<a class="anchor" href="#Overview" aria-hidden="true"><span class="octicon octicon-link"></span></a>Overview<a class="anchor-link" href="#Overview"> </a>
</h2>
<p>In this notebook, we'll take a look in more detail about how to set up a segmentation network dynamically from a given ResNet backbone. Specifically, we'll take advantage of PyTorch hooks to setup the decoder layers for outputting a segmentation, in the scheme shown in the U-Net paper (image shown below). 
<img src="/technical_blog/images/copied_from_nb/my_icons/u-net-architecture.png" alt="alt text"></p>
<p>The left half of the network will be referred to frequently as the encoder, and the right half of the network will be referred to frequently as the decoder. Briefly, the novel proposition when the U-Net paper was published was the idea of using skip connections (here, from the encoder to the decoder) to combat any loss of information when upsampling.</p>
<p>Concretely, by using skip connections that concatenate a level of encoder's output with the input to the corresponding level of the decoder, whenever an upsampling operation is done, there is 2 times the amount of information in the number of channels that is used for upsampling.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Encoder-Setup">
<a class="anchor" href="#Encoder-Setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Encoder Setup<a class="anchor-link" href="#Encoder-Setup"> </a>
</h2>
<p>We'll first setup the code for the ResNet backbone (i.e. the encoder in the U-Net network, or the left-hand side).</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">import</span> <span class="nn">tifffile</span> <span class="k">as</span> <span class="nn">tiff</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">torch.nn</span> <span class="k">as</span> <span class="nn">nn</span>
<span class="kn">import</span> <span class="nn">torch.optim</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">from</span> <span class="nn">torch.nn</span> <span class="kn">import</span> <span class="n">functional</span> <span class="k">as</span> <span class="n">F</span>
<span class="kn">import</span> <span class="nn">torch.utils.model_zoo</span> <span class="k">as</span> <span class="nn">model_zoo</span>
<span class="kn">import</span> <span class="nn">torchvision.transforms.functional</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The point of using the ResNet backbone is to leverage the pre-trained weights we can get from PyTorch's model zoo. The links are set up below, and will be used in our implementation for fetching the ResNet encoder backbone.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">model_urls</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'resnet18'</span><span class="p">:</span> <span class="s1">'https://download.pytorch.org/models/resnet18-5c106cde.pth'</span><span class="p">,</span>
    <span class="s1">'resnet34'</span><span class="p">:</span> <span class="s1">'https://download.pytorch.org/models/resnet34-333f7ec4.pth'</span><span class="p">,</span>
    <span class="s1">'resnet50'</span><span class="p">:</span> <span class="s1">'https://download.pytorch.org/models/resnet50-19c8e357.pth'</span><span class="p">,</span>
    <span class="s1">'resnet101'</span><span class="p">:</span> <span class="s1">'https://download.pytorch.org/models/resnet101-5d3b4d8f.pth'</span><span class="p">,</span>
    <span class="s1">'resnet152'</span><span class="p">:</span> <span class="s1">'https://download.pytorch.org/models/resnet152-b121ed2d.pth'</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This code is taken from the official PyTorch implementations for ResNets. Some things are not ideal with how they initially trained these networks (based on recent empirical findings), but otherwise, these pre-trained weights are very useful as we now have a very good baseline to start with for segmentation of real images.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="k">def</span> <span class="nf">conv3x3</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""3x3 convolution with padding"""</span>
    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span>
                     <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">conv1x1</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">"""1x1 convolution"""</span>
    <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_planes</span><span class="p">,</span> <span class="n">out_planes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BasicBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="n">expansion</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BasicBlock</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">conv3x3</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">conv3x3</span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="n">downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="n">residual</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">Bottleneck</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="n">expansion</span> <span class="o">=</span> <span class="mi">4</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">downsample</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">conv1x1</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span> <span class="o">=</span> <span class="n">conv3x3</span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">stride</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span> <span class="o">=</span> <span class="n">conv1x1</span><span class="p">(</span><span class="n">planes</span><span class="p">,</span> <span class="n">planes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn3</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">expansion</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="n">downsample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stride</span> <span class="o">=</span> <span class="n">stride</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">residual</span> <span class="o">=</span> <span class="n">x</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn2</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn3</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">residual</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="n">residual</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The nice thing about ResNets are the residual blocks - these form very clear levels for the encoder and decoder of our U-Net to interface with. This is made even more clear in the implementation of the ResNet network - the variables <code>self.layer1</code> to <code>self.layer4</code> comprise these levels, and <code>self.layer0</code> comprises the initial input encoding for the ResNet (generally going from the standard 3 channels of input from the image to 64 channels, i.e. 64 filters).</p>
<p>The implementation is modified slightly from the original PyTorch version. Specifically:</p>
<ul>
<li>We don't need the last FC layer, as we'll have something different for connecting to the decoder</li>
<li>We encompass the input encoding for the network (<code>self.conv1</code> to <code>self.bn1</code> to <code>self.relu</code>) in <code>self.layer0</code> for clarity in the <code>forward</code> function</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="k">class</span> <span class="nc">ResNetEncoder</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">layers</span><span class="p">,</span> <span class="n">num_classes</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ResNetEncoder</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span> <span class="o">=</span> <span class="mi">64</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conv1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                               <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="mi">64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relu</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ReLU</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxpool</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">MaxPool2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer0</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conv1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">relu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxpool</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="mi">128</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layer4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_layer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="mi">512</span><span class="p">,</span> <span class="n">layers</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">stride</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_dim</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">expansion</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">modules</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">):</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">kaiming_normal_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'fan_out'</span><span class="p">,</span> <span class="n">nonlinearity</span><span class="o">=</span><span class="s1">'relu'</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">):</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">constant_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">constant_</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">bias</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">downsample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span> <span class="o">!=</span> <span class="n">planes</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">expansion</span><span class="p">:</span>
            <span class="n">downsample</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
                <span class="n">conv1x1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">expansion</span><span class="p">,</span> <span class="n">stride</span><span class="p">),</span>
                <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">planes</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">expansion</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="n">layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">downsample</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span> <span class="o">=</span> <span class="n">planes</span> <span class="o">*</span> <span class="n">block</span><span class="o">.</span><span class="n">expansion</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">):</span>
            <span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">planes</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">layers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer0</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer4</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, we can load the pre-trained weights from the <code>model_urls</code> defined above. This is made easy using the utility API in PyTorch, <code>model_zoo</code>. Then, because we modified the ResNet implementation slightly, but kept the parameter names the same, we can load the state dictionary for any parameters still present (e.g. <code>self.conv1</code>, <code>self.bn1</code>, <code>self.relu</code>, and the <code>self.layer</code>s) without being strict to load as much of the pre-trained weights as possible.</p>
<p>These function definitions (shown below) are again taken from the official PyTorch implementation, but the modification of making the weight loading non-strict, and (by default) loading a pre-trained network.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="k">def</span> <span class="nf">resnet18</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Constructs a ResNet-18 model.</span>
<span class="sd">    Args:</span>
<span class="sd">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNetEncoder</span><span class="p">(</span><span class="n">BasicBlock</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pretrained</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_zoo</span><span class="o">.</span><span class="n">load_url</span><span class="p">(</span><span class="n">model_urls</span><span class="p">[</span><span class="s1">'resnet18'</span><span class="p">]),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">resnet34</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Constructs a ResNet-34 model.</span>
<span class="sd">    Args:</span>
<span class="sd">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNetEncoder</span><span class="p">(</span><span class="n">BasicBlock</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pretrained</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_zoo</span><span class="o">.</span><span class="n">load_url</span><span class="p">(</span><span class="n">model_urls</span><span class="p">[</span><span class="s1">'resnet34'</span><span class="p">]),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">resnet50</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Constructs a ResNet-50 model.</span>
<span class="sd">    Args:</span>
<span class="sd">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNetEncoder</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pretrained</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_zoo</span><span class="o">.</span><span class="n">load_url</span><span class="p">(</span><span class="n">model_urls</span><span class="p">[</span><span class="s1">'resnet50'</span><span class="p">]),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">resnet101</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Constructs a ResNet-101 model.</span>
<span class="sd">    Args:</span>
<span class="sd">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNetEncoder</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pretrained</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_zoo</span><span class="o">.</span><span class="n">load_url</span><span class="p">(</span><span class="n">model_urls</span><span class="p">[</span><span class="s1">'resnet101'</span><span class="p">]),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>


<span class="k">def</span> <span class="nf">resnet152</span><span class="p">(</span><span class="n">pretrained</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">"""Constructs a ResNet-152 model.</span>
<span class="sd">    Args:</span>
<span class="sd">        pretrained (bool): If True, returns a model pre-trained on ImageNet</span>
<span class="sd">    """</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">ResNetEncoder</span><span class="p">(</span><span class="n">Bottleneck</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pretrained</span><span class="p">:</span>
        <span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">model_zoo</span><span class="o">.</span><span class="n">load_url</span><span class="p">(</span><span class="n">model_urls</span><span class="p">[</span><span class="s1">'resnet152'</span><span class="p">]),</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">model</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Decoder-Setup">
<a class="anchor" href="#Decoder-Setup" aria-hidden="true"><span class="octicon octicon-link"></span></a>Decoder Setup<a class="anchor-link" href="#Decoder-Setup"> </a>
</h2>
<p>Now that we have our setup for the pre-trained ResNet encoder, we need to automatically construct the Decoder using the architecture given in the encoder. To do so, we'll define some helper layers as <code>nn.Module</code>s.</p>
<ul>
<li>
<code>ConvLayer</code> is just a general form of a convolution, ReLU, and batch normalization layer in sequence, with some empirical bets practices (e.g. initializing using $\frac{1}{\sqrt{5}}$ for all the weights in the convolutional layer, as per the FastAI course).</li>
<li>
<code>ConcatLayer</code> is just a thin wrapper on the <code>torch.cat</code> function that concatenates all inputs along the channel dimension, assuming inputs are image batches, i.e. they have shape (batch size, num channels, height, width).</li>
<li>
<code>LambdaLayer</code> is just a thin wrapper of a generic lambda function</li>
<li>
<code>upconv2x2</code> is a utility function for setting up convolutions that upsample an image. As mentioned above, in the U-Net architecture, we first concatenate the encoder output with the corresponding decoder input, so that when we upsample an image (i.e. from $(h, w)$ in size to $(2h, 2w)$ in size), we always have 2 times the amount of information (in this case, from having two times the number of channels). Accordingly, we will always convolve using an atrous convolution (where we dilate the kernel, rather than inserting 0s in the input to the convolutional layer), followed by the actual upsampling operation (using bilinear upsampling).</li>
</ul>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">ConvLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">,</span> <span class="n">bn</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">padding</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">transpose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ConvLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">padding</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="k">if</span> <span class="n">transpose</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">transpose</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ConvTranspose2d</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                            <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="n">dilation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">num_inputs</span><span class="p">,</span> <span class="n">num_filters</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">,</span>
                                   <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">init</span><span class="o">.</span><span class="n">kaiming_uniform_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bn_layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">BatchNorm2d</span><span class="p">(</span><span class="n">num_filters</span><span class="p">)</span> <span class="k">if</span> <span class="n">bn</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn_layer</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn_layer</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">ConcatLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">LambdaLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LambdaLayer</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">f</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">upconv2x2</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">outplanes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">outplanes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Upsample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'bilinear'</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">outplanes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dilation</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">stride</span><span class="o">=</span><span class="n">stride</span><span class="p">),</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">Upsample</span><span class="p">(</span><span class="n">scale_factor</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'bilinear'</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Some specifics in how the decoder is coordinated (here, the first layer means the input encoding layer of the encoder, and the last layer indicates the last layer in the encoder). These details are not super important, and are probably understandable if you inspect the U-Net architecture image more closely.</p>
<ul>
<li>The first layer's output passed along, concatenated, fed through <code>conv3x3</code> before upsampling, then fed through a regular <code>conv3x3</code> two times, then a <code>conv1x1</code> to output the right number of channels for segmentation output</li>
<li>The middle layers output all are passed along, concatenated, and fed through a <code>conv3x3</code> that first halves number of channels to upsample, then a regular <code>conv3x3</code>
</li>
<li>The last layer output's takes two pathways:<ul>
<li>Going down in the figure, the output goes through: max-pool (2x2), conv3x3, conv3x3, upconv2x2. These operations are encompassed in the <code>DecoderConnect</code> class.</li>
<li>Going across, assed across and concatenated to the result of above step</li>
</ul>
</li>
</ul>
<p>Again, these details don't particularly matter, unless you're implementing the architecture yourself. The important point is that upsampling always happens after a concatenation of the encoder's output with the corresponding input to the corresponding level of the decoder.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="k">class</span> <span class="nc">DecoderConnect</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">output_size</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DecoderConnect</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bottom_process</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
            <span class="o">*</span><span class="n">upconv2x2</span><span class="p">(</span><span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">output_size</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concat_process</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span>
            <span class="n">ConcatLayer</span><span class="p">(),</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">ConvLayer</span><span class="p">(</span><span class="n">inplanes</span><span class="p">,</span> <span class="n">inplanes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">decoder_input</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bottom_process</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">concat_process</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">decoder_input</span><span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The crux of constructing the decoder happens in the <code>setup_decoder</code> function call below, and consequently in the <code>construct_decoder</code>. The details are hard to extract from the code below, so we can break it down as follows (tracing the code in the <code>setup_decoder</code> function first.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Getting-Shapes-Using-Hooks">
<a class="anchor" href="#Getting-Shapes-Using-Hooks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting Shapes Using Hooks<a class="anchor-link" href="#Getting-Shapes-Using-Hooks"> </a>
</h3>
<p>We're going to gather the input size and output size of a tensor to any layer in the ResNet encoder network with a name that has the prefix "layer". To do so, we'll use hooks. Specifically, a hook is a closure, i.e. a function that's passed as an argument when registering a hook for a specific layer in our network. You can see here that</p>
<ul>
<li>
<code>shape_hook</code> is the function passed when registering a hook</li>
<li>We <code>register_forward_hook</code> for any <code>child</code> layer of our network that has a name that <code>startswith</code> layer, e.g. <code>self.layer0</code>, <code>self.layer1</code>, and so on.</li>
</ul>
<p>Note the specification for <code>shape_hook</code>, and generally for the function passed to <code>register_forward_hook</code> - it will have access to the input and output of the layer we are calling <code>register_forward_hook</code> for (note that input and output can be tuples here). In our case, we only care about their shapes, as we'll need the shape to determine the shape of the decoder's input, and accordingly the number of filters the convolutional layers need to output in the previous layer.</p>
<p>Accordingly, we'll take those shapes, and add them to our <code>input_sizes</code> and <code>output_sizes</code> array, to keep track of the input and output shapes as the network processes an input. To actually populate these arrays, we have to do exctly that - process an input. Thus, we'll make a dummy input (in the code, <code>test_input</code>) that we pass through our encoder, and after it finishes processing that input, our <code>input_sizes</code> and <code>output_sizes</code> array will be populated!</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Constructing-the-Decoder">
<a class="anchor" href="#Constructing-the-Decoder" aria-hidden="true"><span class="octicon octicon-link"></span></a>Constructing the Decoder<a class="anchor-link" href="#Constructing-the-Decoder"> </a>
</h3>
<p>Now that we have the input and output sizes of any tensors passing through the blocks of our ResNet encoder, we can construct our decoder level by level. To do so, we'll just look at the following things:</p>
<ul>
<li>How much we need to upsample the size of the image (determined by looking at the ratio of the input image size and the output image size)</li>
<li>What the difference in channels between the input and output of the corresponding encoder level are (determined by looking at the ratio of channels between input and output)</li>
</ul>
<p>Looking at both of these gives us a sense of the operation we need to do to reverse what the encoder did. Specifically, we can abide by the following assumptions when constructing the decoder:</p>
<ul>
<li>The shape of the input to the level of the decoder we're working on will be the same as the shape of the output of the corresponding level of the encoder</li>
<li>The shape of the output of this level of the decoder will be the same shape as the shape of the input of the corresponding level of the encoder</li>
</ul>
<p>With these assumptions in mind, and using the details above for constructing the operations for each level of the decoder, we can just use case work for actually constructing the decoder, depending on whether we're looking at the last layer of the encoder, one of the middle layers, or the first layer of the encoder.</p>
<p>Since we're starting from the inputs and outputs of the first layer of the encoder, we add on the constructed layers as we inspect the shapes of the inputs and outputs of the encoder, and then reverse the list of constructed layers when finalizing the decoder architecture, to ensure that we go from the last output shape of the encoder to the first input shape of the encoder, which is (generally) what we want to output for segmentation. (This doesn't necessarily have to be true, in which case, a 1x1 convolution is added at the end of the decoder to get the right number of output channels, specified in the constructing of the class as <code>num_output_channels</code>.</p>
<p>Note that we maintain the decoder as a list of modules, i.e. an <code>nn.ModuleList</code>. This is an intentional choice, as we'll need to perform the operations of our network in sequence by level, as each level requires getting the corresponding output of the encoder, and processing it alongside the corresponding input of the decoder.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Model-Forward-Using-Hooks">
<a class="anchor" href="#Model-Forward-Using-Hooks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Model Forward Using Hooks<a class="anchor-link" href="#Model-Forward-Using-Hooks"> </a>
</h3>
<p>The last part of setting up our dynamic U-Net architecture is to specify the <code>forward</code> function. In order to do so, we need to keep track of the outputs of each level of our encoder. Since we've encompassed the encoder as one module when constructing our U-Net, the easiest way to get the outputs for each level of the encoder is to just use hooks again.</p>
<p>The setup for these hooks is very similar to how we set up the shape hooks above, but instead, we only keep track of the outputs, and we want the actual output tensor, not the shape. This is encompassed in the <code>encoder_output_hook</code> hook in the forward function below. Again, we register the hook for all layers in our encoder that have name starting with "layer".</p>
<p>To actually use these outputs, we only need to keep track of the corresponding input we are passing into the current level of the decoder. This becomes convenient to do since we left the decoder as an <code>nn.ModuleList</code>, so we need only iterate over the encoder outputs and the corresponding layer of the decoder that they'll be passed into with the corresponding input to the decoder. This is encompassed in the following loop in the <code>forward</code> function:</p>

<pre><code>prev_output = None
for reo, rdl in zip(reversed(encoder_outputs), self.decoder):
    if prev_output is not None:
        prev_output = rdl({0: reo, 1: prev_output})
    else:
        prev_output = rdl(reo)</code></pre>
<p>Note how that for the first layer of the decoder (the one that ties with the last layer of the encoder), there's no previous output. This is because the first layer of the decoder has the additional pathway (seen at the bottom of the U-Net architecture figure) that is concatenated with the output of the last layer of the encoder. On the other hand, for all other layers, the encoder output (<code>reo</code>) and the decoder input (<code>prev_output</code>) are concatenated together in a single pathway (explicitly, via the <code>ConcatLayer</code> forward function).</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="k">class</span> <span class="nc">DynamicUNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">encoder</span><span class="p">,</span> <span class="n">input_size</span><span class="o">=</span><span class="p">(</span><span class="mi">224</span><span class="p">,</span> <span class="mi">224</span><span class="p">),</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DynamicUNet</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span> <span class="o">=</span> <span class="n">encoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_size</span> <span class="o">=</span> <span class="n">input_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_input_channels</span> <span class="o">=</span> <span class="mi">3</span>  <span class="c1"># This must be 3 because we're using a ResNet encoder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span> <span class="o">=</span> <span class="n">num_output_channels</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">setup_decoder</span><span class="p">()</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="n">encoder_outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">encoder_output_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="n">encoder_outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>

        <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">child</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">encoder_output_hook</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">named_children</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'layer'</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Removing all forward handles"</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">:</span>
                <span class="n">handle</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

        <span class="n">prev_output</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">reo</span><span class="p">,</span> <span class="n">rdl</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">encoder_outputs</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">decoder</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prev_output</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prev_output</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">({</span><span class="mi">0</span><span class="p">:</span> <span class="n">reo</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="n">prev_output</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev_output</span> <span class="o">=</span> <span class="n">rdl</span><span class="p">(</span><span class="n">reo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prev_output</span>
                
    <span class="k">def</span> <span class="nf">setup_decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">input_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">output_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">def</span> <span class="nf">shape_hook</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">):</span>
            <span class="n">input_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">output_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">child</span><span class="o">.</span><span class="n">register_forward_hook</span><span class="p">(</span><span class="n">shape_hook</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">named_children</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">'layer'</span><span class="p">)</span>
        <span class="p">]</span>    

        <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
        <span class="n">test_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_input_channels</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">input_size</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">encoder</span><span class="p">(</span><span class="n">test_input</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">"Removing all shape hook handles"</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">:</span>
                <span class="n">handle</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="n">decoder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">construct_decoder</span><span class="p">(</span><span class="n">input_sizes</span><span class="p">,</span> <span class="n">output_sizes</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">decoder</span>
        
    <span class="k">def</span> <span class="nf">construct_decoder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_sizes</span><span class="p">,</span> <span class="n">output_sizes</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">decoder_layers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">layer_index</span><span class="p">,</span> <span class="p">(</span><span class="n">input_size</span><span class="p">,</span> <span class="n">output_size</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">input_sizes</span><span class="p">,</span> <span class="n">output_sizes</span><span class="p">)):</span>
            <span class="n">upsampling_size_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">input_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">upsampling_channel_factor</span> <span class="o">=</span> <span class="n">input_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">next_layer</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">bs</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">input_size</span>
            <span class="n">ops</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">layer_index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_sizes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">last_layer_ops</span> <span class="o">=</span> <span class="n">DecoderConnect</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">output_size</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                <span class="n">last_layer_ops_input</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">output_size</span><span class="p">)</span>
                <span class="n">last_layer_concat_ops_output</span> <span class="o">=</span> <span class="n">last_layer_ops</span><span class="p">(</span><span class="n">last_layer_ops_input</span><span class="p">)</span>
                <span class="n">next_layer</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">last_layer_ops</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">upsampling_size_factor</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">upsampling_channel_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">last_layer_concat_upconv_op</span> <span class="o">=</span> <span class="n">upconv2x2</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">input_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">input_size</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                    <span class="n">last_layer_concat_upconv_op_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">last_layer_concat_upconv_op</span><span class="p">)(</span>
                        <span class="n">last_layer_concat_ops_output</span>
                    <span class="p">)</span>
                    <span class="n">next_layer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">last_layer_concat_upconv_op</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">layer_index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">first_layer_concat_ops</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ConcatLayer</span><span class="p">(),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="o">*</span><span class="n">upconv2x2</span><span class="p">(</span>
                        <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span>
                        <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span>
                        <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">dim</span> <span class="o">*</span> <span class="n">upsampling_size_factor</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">output_size</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span>
                    <span class="p">),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span>
                        <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span>
                        <span class="n">input_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_output_channels</span><span class="p">,</span>
                        <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span>
                    <span class="p">),</span>
                <span class="p">]</span>
                <span class="n">first_layer_concat_ops_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">first_layer_concat_ops</span><span class="p">)(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">output_size</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">output_size</span><span class="p">)}</span>
                <span class="p">)</span>
                <span class="n">next_layer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">first_layer_concat_ops</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">middle_layer_concat_ops</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ConcatLayer</span><span class="p">(),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">),</span>
                    <span class="n">ConvLayer</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
                <span class="p">]</span>
                <span class="n">middle_layer_concat_ops_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">middle_layer_concat_ops</span><span class="p">)(</span>
                    <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">output_size</span><span class="p">),</span> <span class="mi">1</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">output_size</span><span class="p">)}</span>
                <span class="p">)</span>
                <span class="n">next_layer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">middle_layer_concat_ops</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">upsampling_size_factor</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">upsampling_channel_factor</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">middle_layer_concat_upconv_op</span> <span class="o">=</span> <span class="n">upconv2x2</span><span class="p">(</span><span class="n">output_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">input_size</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">input_size</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>
                    <span class="n">middle_layer_concat_upconv_op_output</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">middle_layer_concat_upconv_op</span><span class="p">)(</span>
                        <span class="n">middle_layer_concat_ops_output</span>
                    <span class="p">)</span>
                    <span class="n">next_layer</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">middle_layer_concat_upconv_op</span><span class="p">)</span>
            <span class="n">decoder_layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="o">*</span><span class="n">next_layer</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">decoder_layers</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Testing-on-the-CamVid-Dataset">
<a class="anchor" href="#Testing-on-the-CamVid-Dataset" aria-hidden="true"><span class="octicon octicon-link"></span></a>Testing on the CamVid Dataset<a class="anchor-link" href="#Testing-on-the-CamVid-Dataset"> </a>
</h2>
<p>For this example, we'll use the CamVid dataset, since they correspond to natural (3 channel) images, which is what our ResNet encoder expects.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="k">def</span> <span class="nf">load_camvid_dataset</span><span class="p">(</span><span class="n">data_directory</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"valid.txt"</span><span class="p">),</span> <span class="s2">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">val_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">]</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"codes.txt"</span><span class="p">),</span> <span class="s2">"r"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">label_mapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">l</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">f</span><span class="p">)}</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">image_index_mapping</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">im_f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"images"</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">im_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">'png'</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">image_index_mapping</span><span class="p">[</span><span class="n">im_f</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"images"</span><span class="p">,</span> <span class="n">im_f</span><span class="p">)</span>
        <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label_f</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">listdir</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"labels"</span><span class="p">)):</span>
        <span class="n">im_f</span> <span class="o">=</span> <span class="n">label_f</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'.'</span><span class="p">)</span>
        <span class="n">im_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'_'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">im_f</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">'_'</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">im_f</span> <span class="o">=</span> <span class="s1">'.'</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">im_f</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">image_index_mapping</span><span class="p">[</span><span class="n">im_f</span><span class="p">]</span>
        <span class="n">fp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_directory</span><span class="p">,</span> <span class="s2">"labels"</span><span class="p">,</span> <span class="n">label_f</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">fp</span><span class="p">)</span>
    <span class="n">val_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">image_index_mapping</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">val_names</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">,</span> <span class="n">label_mapping</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">camvid_data_directory</span> <span class="o">=</span> <span class="s2">"/home/jupyter/data/camvid"</span>
<span class="n">all_data</span><span class="p">,</span> <span class="n">val_indices</span><span class="p">,</span> <span class="n">label_mapping</span> <span class="o">=</span> <span class="n">load_camvid_dataset</span><span class="p">(</span><span class="n">camvid_data_directory</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We'll split the data for now into training and validation, based on the split specified in the dataset itself.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="n">tr_data</span><span class="p">,</span> <span class="n">val_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">tpl</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">val_indices</span><span class="p">],</span> \
                    <span class="p">[</span><span class="n">tpl</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_data</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">val_indices</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="k">def</span> <span class="nf">display_segmentation</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ax</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'gray'</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ax</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'jet'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">'jet'</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        
<span class="k">def</span> <span class="nf">display_segmentation_from_file</span><span class="p">(</span><span class="n">im_f</span><span class="p">,</span> <span class="n">label_f</span><span class="p">):</span>
    <span class="n">im</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">im_f</span><span class="p">),</span> <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">label_f</span><span class="p">)</span>
    <span class="n">display_segmentation</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can visualize some examples and their corresponding segmentations overlayed.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">display_segmentation_from_file</span><span class="p">(</span><span class="n">tr_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">tr_data</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_png output_subarea ">
<img src="data:image/png;base64,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%0A">
</div>

</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, we'll use a simple dataset class that transforms each image and it's corresponding segmentation label by randomly (with probably 0.5) vertically flipping, randomly (with probably 0.5) horizontally flipping, and then normalizing the input image using the standard ImageNet normalization statistics.</p>
<p>We also specify a resize shape, defaulting to 360 by 480, where nearest neighbor interpolation is used for resizing.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description" open="">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_show</span>
<span class="k">class</span> <span class="nc">CamvidDataset</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">Dataset</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">resize_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">is_train</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">tpl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">data</span><span class="p">],</span> \
                                   <span class="p">[</span><span class="n">tpl</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">tpl</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resize_shape</span> <span class="o">=</span> <span class="n">resize_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_train</span> <span class="o">=</span> <span class="n">is_train</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="nb">input</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span>
            <span class="n">Image</span><span class="o">.</span><span class="n">open</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="nb">input</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resize_shape</span><span class="p">),</span>
            <span class="n">tf</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resize_shape</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="n">Image</span><span class="o">.</span><span class="n">NEAREST</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_train</span><span class="p">:</span>
            <span class="n">horizontal_draw</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="n">vertical_draw</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">horizontal_draw</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="nb">input</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">hflip</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">hflip</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">vertical_draw</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
                <span class="nb">input</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">vflip</span><span class="p">(</span><span class="nb">input</span><span class="p">),</span> <span class="n">tf</span><span class="o">.</span><span class="n">vflip</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        
        <span class="nb">input</span><span class="p">,</span> <span class="n">target</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">to_tensor</span><span class="p">,</span> <span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="mi">255</span> <span class="o">*</span> <span class="n">target</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tf</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.485</span><span class="p">,</span> <span class="mf">0.456</span><span class="p">,</span> <span class="mf">0.406</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.229</span><span class="p">,</span> <span class="mf">0.224</span><span class="p">,</span> <span class="mf">0.225</span><span class="p">]),</span> <span class="n">target</span><span class="o">.</span><span class="n">long</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">images</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tr_ds</span><span class="p">,</span> <span class="n">val_ds</span> <span class="o">=</span> <span class="n">CamvidDataset</span><span class="p">(</span><span class="n">tr_data</span><span class="p">,</span> <span class="n">resize_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">480</span><span class="p">)),</span>\
                <span class="n">CamvidDataset</span><span class="p">(</span><span class="n">val_data</span><span class="p">,</span> <span class="n">resize_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">480</span><span class="p">),</span> <span class="n">is_train</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">tr_dl</span><span class="p">,</span> <span class="n">val_dl</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">tr_ds</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">shuffle</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">torch</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">DataLoader</span><span class="p">(</span><span class="n">val_ds</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>One last thing that will be useful is the Dice loss, used commonly in segmentation. It is implemented below. We use the differentiable variant (i.e. the smooth variant). In the literature, both the Dice loss and cross-entropy are used, with comparable results. For the purpose of this blog post, we'll optimize directly for the Dice score.</p>
<p>In paritcular, the reason for using the Dice score is that it is just the F1 score, which is the harmonic mean of the precision $P$ and the recall $R$. Specifically, we can write it as:</p>
<p>
$$\frac{1}{\frac{1}{P} + \frac{1}{R}}$$
</p>
<p>By using this loss, we optimize equally for precision and recall, where optimizing for cross-entropy is (theoretically) a bit more difficult due to background pixels being more likely to occur than specific class pixels.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">class</span> <span class="nc">DiceLoss</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Module to compute the Dice segmentation loss. Based on the following discussion:</span>
<span class="sd">    https://discuss.pytorch.org/t/one-hot-encoding-with-autograd-dice-loss/9781</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">DiceLoss</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="n">weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_index</span> <span class="o">=</span> <span class="n">ignore_index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>
        
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">"""</span>
<span class="sd">        Arguments:</span>
<span class="sd">            output: (N, C, H, W) tensor of probabilities for the predicted output</span>
<span class="sd">            target: (N, H, W) tensor corresponding to the pixel-wise labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            loss: the Dice loss averaged over channels</span>
<span class="sd">        """</span> 
        <span class="n">encoded_target</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">target</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_index</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
            <span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">encoded_target</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">encoded_target</span><span class="p">)</span>
            <span class="n">encoded_target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">encoded_target</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">intersection</span> <span class="o">=</span> <span class="n">output</span> <span class="o">*</span> <span class="n">encoded_target</span>
        <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">intersection</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">output</span> <span class="o">+</span> <span class="n">encoded_target</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">denominator</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span>
        <span class="n">loss_per_channel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">loss_per_channel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">dice_similarity</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">"""</span>
<span class="sd">    Arguments:</span>
<span class="sd">        output: (N, C, H, W) tensor of model output</span>
<span class="sd">        target: (N, H, W) tensor corresponding to the pixel-wise labels</span>
<span class="sd">    Returns:</span>
<span class="sd">        loss: the Dice loss averaged over channels</span>
<span class="sd">    """</span> 
    <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">encoded_prediction</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="n">encoded_prediction</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">prediction</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">encoded_target</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">detach</span><span class="p">()</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">ignore_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">target</span> <span class="o">==</span> <span class="n">ignore_index</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">encoded_target</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">expand_as</span><span class="p">(</span><span class="n">encoded_target</span><span class="p">)</span>
        <span class="n">encoded_target</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">encoded_target</span><span class="o">.</span><span class="n">scatter_</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="n">intersection</span> <span class="o">=</span> <span class="n">encoded_prediction</span> <span class="o">*</span> <span class="n">encoded_target</span>
    <span class="n">numerator</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">intersection</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">intersection</span> <span class="o">+</span> <span class="n">encoded_target</span>
    <span class="k">if</span> <span class="n">ignore_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">denominator</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">denominator</span> <span class="o">=</span> <span class="n">denominator</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">eps</span>
    <span class="n">acc_per_channel</span> <span class="o">=</span> <span class="n">weights</span> <span class="o">*</span> <span class="p">((</span><span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">acc_per_channel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">output</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>To begin, we'll only train the decoder of our model, and freeze the weights of our encoder (since they are pre-trained weights). This is easily done by only specifying the parameters of our decoder in the optimizer settings.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">model</span> <span class="o">=</span> <span class="n">DynamicUNet</span><span class="p">(</span><span class="n">resnet34</span><span class="p">(),</span> <span class="n">num_output_channels</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">input_size</span><span class="o">=</span><span class="p">(</span><span class="mi">360</span><span class="p">,</span> <span class="mi">480</span><span class="p">))</span>
<span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
    <span class="n">model</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<span class="n">decoder_parameters</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">model</span><span class="o">.</span><span class="n">decoder</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">module</span><span class="o">.</span><span class="n">parameters</span><span class="p">()]</span>
<span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">(</span><span class="n">decoder_parameters</span><span class="p">)</span>  <span class="c1"># Only training the decoder for now</span>

<span class="n">criterion</span> <span class="o">=</span> <span class="n">DiceLoss</span><span class="p">()</span>

<span class="c1"># Training specific parameters</span>
<span class="n">num_epochs</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_up_epochs</span><span class="p">,</span> <span class="n">num_down_epochs</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">7</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">OneCycleLR</span><span class="p">(</span>
    <span class="n">optimizer</span><span class="p">,</span> <span class="n">max_lr</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">,</span>
    <span class="n">total_steps</span><span class="o">=</span><span class="n">num_epochs</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_dl</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We'll train for 10 epochs to fine-tune the decoder to be on par with the pre-trained weights being used in the ResNet encoder. We're using the default learning rate for Adam, $10^{-3}$. We'll print the per-pixel accuracy, as well as the Dice similarity (which is the F1 score).</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p></p>
<div class="flash flash-error">
    <svg class="octicon octicon-alert" viewbox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 000 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 00.01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"></path></svg>
    <strong>Warning: </strong>The following cell runs training, and might take a while - take caution if you’re using a preemptible instance of a cloud service.
</div>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>
<span class="n">losses</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">accuracies</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">tqdm_iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">tqdm_iterator</span><span class="p">:</span>
    <span class="n">tr_loss</span><span class="p">,</span> <span class="n">tr_correct_pixels</span><span class="p">,</span> <span class="n">tr_total_pixels</span><span class="p">,</span> <span class="n">tr_dice_similarity</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>
    <span class="n">tqdm_epoch_iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">tr_dl</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm_epoch_iterator</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tr_correct_pixels</span> <span class="o">+=</span> <span class="p">((</span><span class="n">prediction</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">tr_total_pixels</span> <span class="o">+=</span> <span class="n">y</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
        <span class="n">tr_dice_similarity</span> <span class="o">+=</span> <span class="n">dice_similarity</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">tr_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">scheduler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_loss</span> <span class="o">=</span> <span class="n">tr_loss</span> <span class="o">/</span> <span class="n">total</span>
            <span class="n">curr_acc</span> <span class="o">=</span> <span class="n">tr_correct_pixels</span> <span class="o">/</span> <span class="n">tr_total_pixels</span>
            <span class="n">curr_dice</span> <span class="o">=</span> <span class="n">tr_dice_similarity</span> <span class="o">/</span> <span class="n">total</span>
            <span class="n">tqdm_epoch_iterator</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">({</span>
                <span class="s2">"Loss"</span><span class="p">:</span> <span class="n">curr_loss</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="s2">"Accuracy"</span><span class="p">:</span> <span class="n">curr_acc</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="s2">"Dice"</span><span class="p">:</span> <span class="n">curr_dice</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
            <span class="p">})</span>
    <span class="n">overall_loss</span> <span class="o">=</span> <span class="n">tr_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">total</span>
    <span class="n">overall_acc</span> <span class="o">=</span> <span class="n">tr_correct_pixels</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">tr_total_pixels</span>
    <span class="n">losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overall_loss</span><span class="p">)</span>
    <span class="n">accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overall_acc</span><span class="p">)</span>
    <span class="n">tqdm_iterator</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">({</span><span class="s2">"Loss"</span><span class="p">:</span> <span class="n">overall_loss</span><span class="p">,</span> <span class="s2">"Accuracy"</span><span class="p">:</span> <span class="n">overall_acc</span><span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

    </details>
<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_text output_error">
<pre>
<span class="ansi-red-fg">---------------------------------------------------------------------------</span>
<span class="ansi-red-fg">KeyboardInterrupt</span>                         Traceback (most recent call last)
<span class="ansi-green-fg">&lt;ipython-input-20-4caa77be1f34&gt;</span> in <span class="ansi-cyan-fg">&lt;module&gt;</span>
<span class="ansi-green-intense-fg ansi-bold">     12</span>         <span class="ansi-green-fg">if</span> torch<span class="ansi-blue-fg">.</span>cuda<span class="ansi-blue-fg">.</span>is_available<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">     13</span>             x<span class="ansi-blue-fg">,</span> y <span class="ansi-blue-fg">=</span> x<span class="ansi-blue-fg">.</span>cuda<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span> y<span class="ansi-blue-fg">.</span>squeeze<span class="ansi-blue-fg">(</span>dim<span class="ansi-blue-fg">=</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">.</span>cuda<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-fg">---&gt; 14</span><span class="ansi-red-fg">         </span>output <span class="ansi-blue-fg">=</span> model<span class="ansi-blue-fg">(</span>x<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     15</span>         probs <span class="ansi-blue-fg">=</span> torch<span class="ansi-blue-fg">.</span>softmax<span class="ansi-blue-fg">(</span>output<span class="ansi-blue-fg">,</span> dim<span class="ansi-blue-fg">=</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     16</span>         prediction <span class="ansi-blue-fg">=</span> torch<span class="ansi-blue-fg">.</span>argmax<span class="ansi-blue-fg">(</span>output<span class="ansi-blue-fg">,</span> dim<span class="ansi-blue-fg">=</span><span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/module.py</span> in <span class="ansi-cyan-fg">__call__</span><span class="ansi-blue-fg">(self, *input, **kwargs)</span>
<span class="ansi-green-intense-fg ansi-bold">    530</span>             result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>_slow_forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    531</span>         <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 532</span><span class="ansi-red-fg">             </span>result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    533</span>         <span class="ansi-green-fg">for</span> hook <span class="ansi-green-fg">in</span> self<span class="ansi-blue-fg">.</span>_forward_hooks<span class="ansi-blue-fg">.</span>values<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    534</span>             hook_result <span class="ansi-blue-fg">=</span> hook<span class="ansi-blue-fg">(</span>self<span class="ansi-blue-fg">,</span> input<span class="ansi-blue-fg">,</span> result<span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">&lt;ipython-input-8-d9839ac87df8&gt;</span> in <span class="ansi-cyan-fg">forward</span><span class="ansi-blue-fg">(self, x)</span>
<span class="ansi-green-intense-fg ansi-bold">     32</span>         <span class="ansi-green-fg">for</span> reo<span class="ansi-blue-fg">,</span> rdl <span class="ansi-green-fg">in</span> zip<span class="ansi-blue-fg">(</span>reversed<span class="ansi-blue-fg">(</span>encoder_outputs<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">,</span> self<span class="ansi-blue-fg">.</span>decoder<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">     33</span>             <span class="ansi-green-fg">if</span> prev_output <span class="ansi-green-fg">is</span> <span class="ansi-green-fg">not</span> <span class="ansi-green-fg">None</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">---&gt; 34</span><span class="ansi-red-fg">                 </span>prev_output <span class="ansi-blue-fg">=</span> rdl<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">{</span><span class="ansi-cyan-fg">0</span><span class="ansi-blue-fg">:</span> reo<span class="ansi-blue-fg">,</span> <span class="ansi-cyan-fg">1</span><span class="ansi-blue-fg">:</span> prev_output<span class="ansi-blue-fg">}</span><span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     35</span>             <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">     36</span>                 prev_output <span class="ansi-blue-fg">=</span> rdl<span class="ansi-blue-fg">(</span>reo<span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/module.py</span> in <span class="ansi-cyan-fg">__call__</span><span class="ansi-blue-fg">(self, *input, **kwargs)</span>
<span class="ansi-green-intense-fg ansi-bold">    530</span>             result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>_slow_forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    531</span>         <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 532</span><span class="ansi-red-fg">             </span>result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    533</span>         <span class="ansi-green-fg">for</span> hook <span class="ansi-green-fg">in</span> self<span class="ansi-blue-fg">.</span>_forward_hooks<span class="ansi-blue-fg">.</span>values<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    534</span>             hook_result <span class="ansi-blue-fg">=</span> hook<span class="ansi-blue-fg">(</span>self<span class="ansi-blue-fg">,</span> input<span class="ansi-blue-fg">,</span> result<span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/container.py</span> in <span class="ansi-cyan-fg">forward</span><span class="ansi-blue-fg">(self, input)</span>
<span class="ansi-green-intense-fg ansi-bold">     98</span>     <span class="ansi-green-fg">def</span> forward<span class="ansi-blue-fg">(</span>self<span class="ansi-blue-fg">,</span> input<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">     99</span>         <span class="ansi-green-fg">for</span> module <span class="ansi-green-fg">in</span> self<span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 100</span><span class="ansi-red-fg">             </span>input <span class="ansi-blue-fg">=</span> module<span class="ansi-blue-fg">(</span>input<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    101</span>         <span class="ansi-green-fg">return</span> input
<span class="ansi-green-intense-fg ansi-bold">    102</span> 

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/module.py</span> in <span class="ansi-cyan-fg">__call__</span><span class="ansi-blue-fg">(self, *input, **kwargs)</span>
<span class="ansi-green-intense-fg ansi-bold">    530</span>             result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>_slow_forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    531</span>         <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 532</span><span class="ansi-red-fg">             </span>result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    533</span>         <span class="ansi-green-fg">for</span> hook <span class="ansi-green-fg">in</span> self<span class="ansi-blue-fg">.</span>_forward_hooks<span class="ansi-blue-fg">.</span>values<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    534</span>             hook_result <span class="ansi-blue-fg">=</span> hook<span class="ansi-blue-fg">(</span>self<span class="ansi-blue-fg">,</span> input<span class="ansi-blue-fg">,</span> result<span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">&lt;ipython-input-6-cc6e2d84af2e&gt;</span> in <span class="ansi-cyan-fg">forward</span><span class="ansi-blue-fg">(self, x)</span>
<span class="ansi-green-intense-fg ansi-bold">     17</span>         out <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>layer<span class="ansi-blue-fg">(</span>x<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     18</span>         out <span class="ansi-blue-fg">=</span> F<span class="ansi-blue-fg">.</span>relu<span class="ansi-blue-fg">(</span>out<span class="ansi-blue-fg">)</span>
<span class="ansi-green-fg">---&gt; 19</span><span class="ansi-red-fg">         </span><span class="ansi-green-fg">return</span> out <span class="ansi-green-fg">if</span> self<span class="ansi-blue-fg">.</span>bn_layer <span class="ansi-green-fg">is</span> <span class="ansi-green-fg">None</span> <span class="ansi-green-fg">else</span> self<span class="ansi-blue-fg">.</span>bn_layer<span class="ansi-blue-fg">(</span>out<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">     20</span> 
<span class="ansi-green-intense-fg ansi-bold">     21</span> <span class="ansi-green-fg">class</span> ConcatLayer<span class="ansi-blue-fg">(</span>nn<span class="ansi-blue-fg">.</span>Module<span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/module.py</span> in <span class="ansi-cyan-fg">__call__</span><span class="ansi-blue-fg">(self, *input, **kwargs)</span>
<span class="ansi-green-intense-fg ansi-bold">    530</span>             result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>_slow_forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    531</span>         <span class="ansi-green-fg">else</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-fg">--&gt; 532</span><span class="ansi-red-fg">             </span>result <span class="ansi-blue-fg">=</span> self<span class="ansi-blue-fg">.</span>forward<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">*</span>input<span class="ansi-blue-fg">,</span> <span class="ansi-blue-fg">**</span>kwargs<span class="ansi-blue-fg">)</span>
<span class="ansi-green-intense-fg ansi-bold">    533</span>         <span class="ansi-green-fg">for</span> hook <span class="ansi-green-fg">in</span> self<span class="ansi-blue-fg">.</span>_forward_hooks<span class="ansi-blue-fg">.</span>values<span class="ansi-blue-fg">(</span><span class="ansi-blue-fg">)</span><span class="ansi-blue-fg">:</span>
<span class="ansi-green-intense-fg ansi-bold">    534</span>             hook_result <span class="ansi-blue-fg">=</span> hook<span class="ansi-blue-fg">(</span>self<span class="ansi-blue-fg">,</span> input<span class="ansi-blue-fg">,</span> result<span class="ansi-blue-fg">)</span>

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/modules/batchnorm.py</span> in <span class="ansi-cyan-fg">forward</span><span class="ansi-blue-fg">(self, input)</span>
<span class="ansi-green-intense-fg ansi-bold">    105</span>             input<span class="ansi-blue-fg">,</span> self<span class="ansi-blue-fg">.</span>running_mean<span class="ansi-blue-fg">,</span> self<span class="ansi-blue-fg">.</span>running_var<span class="ansi-blue-fg">,</span> self<span class="ansi-blue-fg">.</span>weight<span class="ansi-blue-fg">,</span> self<span class="ansi-blue-fg">.</span>bias<span class="ansi-blue-fg">,</span>
<span class="ansi-green-intense-fg ansi-bold">    106</span>             self<span class="ansi-blue-fg">.</span>training <span class="ansi-green-fg">or</span> <span class="ansi-green-fg">not</span> self<span class="ansi-blue-fg">.</span>track_running_stats<span class="ansi-blue-fg">,</span>
<span class="ansi-green-fg">--&gt; 107</span><span class="ansi-red-fg">             exponential_average_factor, self.eps)
</span><span class="ansi-green-intense-fg ansi-bold">    108</span> 
<span class="ansi-green-intense-fg ansi-bold">    109</span> 

<span class="ansi-green-fg">/opt/conda/lib/python3.7/site-packages/torch/nn/functional.py</span> in <span class="ansi-cyan-fg">batch_norm</span><span class="ansi-blue-fg">(input, running_mean, running_var, weight, bias, training, momentum, eps)</span>
<span class="ansi-green-intense-fg ansi-bold">   1668</span>     return torch.batch_norm(
<span class="ansi-green-intense-fg ansi-bold">   1669</span>         input<span class="ansi-blue-fg">,</span> weight<span class="ansi-blue-fg">,</span> bias<span class="ansi-blue-fg">,</span> running_mean<span class="ansi-blue-fg">,</span> running_var<span class="ansi-blue-fg">,</span>
<span class="ansi-green-fg">-&gt; 1670</span><span class="ansi-red-fg">         </span>training<span class="ansi-blue-fg">,</span> momentum<span class="ansi-blue-fg">,</span> eps<span class="ansi-blue-fg">,</span> torch<span class="ansi-blue-fg">.</span>backends<span class="ansi-blue-fg">.</span>cudnn<span class="ansi-blue-fg">.</span>enabled
<span class="ansi-green-intense-fg ansi-bold">   1671</span>     )
<span class="ansi-green-intense-fg ansi-bold">   1672</span> 

<span class="ansi-red-fg">KeyboardInterrupt</span>: </pre>
</div>
</div>

</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can take a look at the losses over time and the accuracies over time.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">losses</span><span class="p">))),</span> <span class="n">losses</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Losses over time for fine-tuning decoder"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies</span><span class="p">))),</span> <span class="n">accuracies</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Accuracies over time for fine-tuning decoder"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's save a model checkpoint so that, if necessary, we can reset back here if our next step goes badly. This is a good practice in general.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="n">decoder_finetuned_model_state_dict</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">output_fp</span> <span class="o">=</span> <span class="s2">"/share/nikola/export/dt372/technical_blog/dynamic_unet/model_ckpts/decoder_finetuned_model_state_dict.pkl"</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_fp</span><span class="p">,</span> <span class="s1">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">decoder_finetuned_model_state_dict</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">output_fp</span><span class="p">,</span> <span class="s1">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">decoder_finetuned_model_state_dict</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">decoder_finetuned_model_state_dict</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, we'll fine-tune the whole network. We'll use a smaller learning rate for the encoder, and a larger, but still small learning rate for the decoder. Ideally, we'd do some sort of learning rate finding scheme (as done in FastAI), but for simplicity, we'll just pick reasonable numbers.</p>
<p>Now we'll train for 20 epochs, and see how the model performs over time.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">optimizer</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">AdamW</span><span class="p">([</span>
    <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">decoder</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="s1">'lr'</span><span class="p">:</span> <span class="mf">1e-4</span><span class="p">},</span>
    <span class="p">{</span><span class="s1">'params'</span><span class="p">:</span> <span class="n">model</span><span class="o">.</span><span class="n">encoder</span><span class="o">.</span><span class="n">parameters</span><span class="p">(),</span> <span class="s1">'lr'</span><span class="p">:</span> <span class="mf">1e-7</span><span class="p">},</span>
<span class="p">])</span>
<span class="n">num_epochs</span> <span class="o">=</span> <span class="mi">20</span>
<span class="n">num_up_epochs</span><span class="p">,</span> <span class="n">num_down_epochs</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">16</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">optim</span><span class="o">.</span><span class="n">lr_scheduler</span><span class="o">.</span><span class="n">CyclicLR</span><span class="p">(</span>
    <span class="n">optimizer</span><span class="p">,</span> <span class="n">base_lr</span><span class="o">=</span><span class="p">[</span><span class="mf">1e-6</span><span class="p">,</span> <span class="mf">1e-8</span><span class="p">],</span> <span class="n">max_lr</span><span class="o">=</span><span class="p">[</span><span class="mf">1e-3</span><span class="p">,</span> <span class="mf">1e-6</span><span class="p">],</span>
    <span class="n">step_size_up</span><span class="o">=</span><span class="n">num_up_epochs</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_dl</span><span class="p">),</span>
    <span class="n">step_size_down</span><span class="o">=</span><span class="n">num_down_epochs</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tr_dl</span><span class="p">),</span>
    <span class="n">mode</span><span class="o">=</span><span class="s1">'exp_range'</span><span class="p">,</span>
    <span class="n">cycle_momentum</span><span class="o">=</span><span class="kc">False</span>  <span class="c1"># Need to set this since we're using AdamW?</span>
<span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">model</span><span class="o">.</span><span class="n">train</span><span class="p">()</span>

<span class="n">tqdm_iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">num_epochs</span><span class="p">),</span> <span class="n">position</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="k">for</span> <span class="n">epoch</span> <span class="ow">in</span> <span class="n">tqdm_iterator</span><span class="p">:</span>
    <span class="n">tr_loss</span><span class="p">,</span> <span class="n">tr_correct_pixels</span><span class="p">,</span> <span class="n">tr_total_pixels</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span>
    <span class="n">tqdm_epoch_iterator</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">tr_dl</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">leave</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tqdm_epoch_iterator</span><span class="p">):</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">zero_grad</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">cuda</span><span class="o">.</span><span class="n">is_available</span><span class="p">():</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tr_correct_pixels</span> <span class="o">+=</span> <span class="p">((</span><span class="n">prediction</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="n">tr_total_pixels</span> <span class="o">+=</span> <span class="n">y</span><span class="o">.</span><span class="n">numel</span><span class="p">()</span>
        <span class="n">loss</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">tr_loss</span> <span class="o">+=</span> <span class="n">loss</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">loss</span><span class="o">.</span><span class="n">backward</span><span class="p">()</span>
        <span class="n">optimizer</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">scheduler</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scheduler</span><span class="o">.</span><span class="n">step</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">curr_loss</span> <span class="o">=</span> <span class="n">tr_loss</span> <span class="o">/</span> <span class="n">total</span>
            <span class="n">curr_acc</span> <span class="o">=</span> <span class="n">tr_correct_pixels</span> <span class="o">/</span> <span class="n">tr_total_pixels</span>
            <span class="n">tqdm_epoch_iterator</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">({</span><span class="s2">"Loss"</span><span class="p">:</span> <span class="n">curr_loss</span><span class="o">.</span><span class="n">item</span><span class="p">(),</span> <span class="s2">"Accuracy"</span><span class="p">:</span> <span class="n">curr_acc</span><span class="o">.</span><span class="n">item</span><span class="p">()})</span>
    <span class="n">overall_loss</span> <span class="o">=</span> <span class="n">tr_loss</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">total</span>
    <span class="n">overall_acc</span> <span class="o">=</span> <span class="n">tr_correct_pixels</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="o">/</span> <span class="n">tr_total_pixels</span>
    <span class="n">losses</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overall_loss</span><span class="p">)</span>
    <span class="n">accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overall_acc</span><span class="p">)</span>
    <span class="n">tqdm_iterator</span><span class="o">.</span><span class="n">set_postfix</span><span class="p">({</span><span class="s2">"Loss"</span><span class="p">:</span> <span class="n">overall_loss</span><span class="p">,</span> <span class="s2">"Accuracy"</span><span class="p">:</span> <span class="n">overall_acc</span><span class="p">})</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Again, let's look at how the losses and accuracies change (after epoch 10 is where we started the above fine-tuning cycle).</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">losses</span><span class="p">))),</span> <span class="n">losses</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Losses over time for fine-tuning decoder"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

    
    
<div class="cell border-box-sizing code_cell rendered">
<details class="description">
      <summary class="btn btn-sm" data-open="Hide Code" data-close="Show Code"></summary>
        <p></p>
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1">#collapse_hide</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">accuracies</span><span class="p">))),</span> <span class="n">accuracies</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">"Accuracies over time for fine-tuning decoder"</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

    </details>
</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, we can visualize some results on the validation dataset. First is the prediction, second is the ground truth.</p>

</div>
</div>
</div>
    
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">index</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">val_dl</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cuda</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">cuda</span><span class="p">()</span>

<span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">()</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">prediction</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cpu</span><span class="p">()</span>

<span class="n">display_segmentation</span><span class="p">(</span><span class="n">tf</span><span class="o">.</span><span class="n">to_pil_image</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cpu</span><span class="p">()),</span> <span class="n">tf</span><span class="o">.</span><span class="n">to_pil_image</span><span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">byte</span><span class="p">()))</span>
<span class="n">display_segmentation_from_file</span><span class="p">(</span><span class="n">val_dl</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">val_dl</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    

<div class="cell border-box-sizing text_cell rendered">
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Clearly, there's some room for improvement.</p>

</div>
</div>
</div>
</div>



  </div><!-- from https://github.com/utterance/utterances -->
<script src="https://utteranc.es/client.js"
        repo="dthiagarajan/technical_blog"
        issue-term="title"
        label="blogpost-comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
<a class="u-url" href="/technical_blog/pytorch/hooks/2020/03/18/Dynamic-UNet-and-PyTorch-Hooks.html" hidden></a>
</article>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/technical_blog/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/technical_blog/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/technical_blog/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
      </div>
      <div class="footer-col">
        <p>Technical blog written by Dilip Thiagarajan.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/dthiagarajan" title="dthiagarajan"><svg class="svg-icon grey"><use xlink:href="/technical_blog/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/iamdilio" title="iamdilio"><svg class="svg-icon grey"><use xlink:href="/technical_blog/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
